{"id": "C:\\Users\\Kota Ajith Kumar\\Downloads\\CNS 4.pdf", "source": "C:\\Users\\Kota Ajith Kumar\\Downloads\\CNS 4.pdf", "content": "UNIT – IV \nCryptographic Data Integrity Algorithms \n \nSyllabus: \nMessage authentication Codes: Message authentication requirements,  Message authentication \nfunctions, HMAC, Digital Signatures: Digital Signatures properties and requirements, Digital \nSignature Standard. \nE-mail Security: PGP, S/MIME. \n \nMessage authentication Codes \nOne of the most fascinating and complex areas of cryptography are that of message authentication and \nthe related area of digital signatures. It would be impossible, in anything less than  book length, to \nexhaust all the cryptographic functions and protocols that have been proposed or implemented for \nmessage authentication and dig - ital signatures. Instead, the purpose of this chapter and the next is to \nprovide a broad overview of the subje ct and to develop a systematic means of describing the various \napproaches. \nMessage authentication is a mechanism or service used to verify the integrity of a message. Message \nauthentication assures that data received are exactly as sent by (i.e., contain n o modification, insertion, \ndeletion, or replay) and that the purported identity of the sender is valid. \n Symmetric encryption provides authentication among those who share the secret key. \n A message authentication code (MAC) is an algorithm that requires the  use of a secret key. A \nMAC takes a variable-length message and a secret key as input and produces an authentication \ncode. A recipient in posses- sion of the secret key can generate an authentication code to verify \nthe integrity of the message. \n One means o f forming a MAC is to combine a cryptographic hash function in some fashion \nwith a secret key. \n Another approach to constructing a MAC is to use a symmetric block cipher in such a way that \nit produces a fixed-length output for a variable- length input. \n4.1. MESSAGE AUTHENTICATION REQUIREMENTS: \nIn the context of communications across a network, the following attacks can be identified.  \n1. Disclosure: Release of message contents to any person or process not possessing the appropria\nte cryptographic key. \n2. Traffic analysis: Discovery of the pattern of traffic between parties. In a connection -oriented \napplication, the frequency and duration of connections could be determined. In either a \nconnection-oriented or connectionless environment, the number and length of mess ages \nbetween parties could be determined. \n3. Masquerade: Insertion of messages into the network from a fraudulent source. This includes \nthe creation of messages by an opponent that are purported to come from an authorized entity. \nAlso included are fraudulent acknowledgments of message receipt  or non receipt by someone \nother than the message recipient. \n4. Content modification: Changes to the contents of a message, including insertion, \ndeletion, transposition, and modification. \n5. Sequence modification: Any modification to a sequence of messages between parties, including i\nnsertion, deletion, and reordering. \n6. Timing modification: Delay or replay of messages. In a connection -oriented application, an \nentire session or sequence of messages could be a replay of some previous valid session, or \nindividual messages in the sequence could be delayed or replayed. In a connectionless application, \nan individual message (e.g., datagram) could be delayed or replayed.  \n7. Source repudiation: Denial of transmission of message by source.  \n8. Destination repudiation: Denial of receipt of message by destination.  \n \nMeasures to deal with the first two attacks are in the realm of message confidentiality and are dealt \nwith in Part One. Measures to deal with items (3) through (6) in the foregoing list are generally regarded \nas message authentication. Mechanisms for dealing specifically with item (7) come under the heading of \ndigital signatures. Generally, a digital signature technique will also counter some or all of the attacks listed \nunder items (3) through (6). Dealing with item (8) may require a combination of the use of digital \nsignatures and a protocol designed to counter this attacks. \n \n4.2. MESSAGE AUTHENTICATION FUNCTIONS:  \nMessage authentication or digital signature mechanism has two levels of functionality. At the \nlower level, there must be some sort of function that produces an authenticator: a value to be used to \nauthenticate a message. This lower -level function is then us ed as a primitive in a higher -level \nauthentication protocol that enables a receiver to verify the authenticity of a message.  \nThis section is concerned with the types of functions that may be used to produce an authenticator. \nThese may be grouped into three classes.  \n Hash function: A hash function  is nothing but a mathematical function that can convert a \nnumeric value into another numeric value that  is compressed. The input to this hash function \ncan be of any length but the output is always of fixed length. The values that a  hash \nfunction returns are called the message  digest or hash values. Message encryption: The cipher \ntext of the entire message serves as its authenticator.  \n Message authentication code (MAC): A message authentication code is a security code that \nthe user of a computer has to type in order to access any account or portal. These codes are \nrecognized by the system so that it can grant access to the right user. These codes help in \nmaintaining information integrity. It also confirms the authenticity of the message \n Message Encryption: Message encryption by itself can provide a measure of authentication. \nThe analysis differs for symmetric and public-key encryption schemes.  \nSymmetric Encryption Consider the straightforward use of symmetric encryption (Figure 4.1).  \nA message transmitted from source A to destination B is encrypted using a secret key shared by \nA and B. If no other party knows the key, then confidentiality is provided: No other party can recover \nthe plaintext of the message.  \nIn addition, B is assured that the message was generated by A. Why? The message must have \ncome from A, because A is the only other party that possesses and therefore the only other party with \nthe information necessary to construct cipher  text that can be decrypted with . Furthermore , if is \nrecovered, B knows that none of the bits of have been altered, because an opponent that does not know \nwould not know how to alter bits in the ciphertext to produce the desired changes in the plaintext. \n So we may say that symmetric encryption provi des authentication as well as confidentiality. \nHowever, this flat statement needs to be qualified. Consider exactly what is happening at B. Given a \ndecryption function D and a secret key , the destination will accept input and produce output . If is the \nciphertext of a legitimate message produced by the corresponding encryption function, then is some \nplaintext message. Otherwise, will likely be a meaningless sequence of bits. There may need to be \n\nsome automated means of determining at B weather is legitimate plaintext and therefore must have \ncome from A. \n \n \nThe implications of the line of reasoning in the preceding paragraph are profound from the point \nof view of authentication. Suppose the message can be any arbitrary bit pattern. In that case, there \nis no way to determine automatically, at the destination, whether an incoming message is the \nciphertext of a legitimate message.  \nThis conclusion is incontrovertible: If can be any bit pattern, then regardless of the value of, the \nvalue is bit pattern and therefore must be accepted as authentic plaintext. \nFor example, suppose that we are transmitting English  language messages using a Caesar cipher \nwith a shift of one (K  1).  \nA sends the following legitimate ciphertext:  \nnbsftfbupbutboeepftfbupbutboemjuumfmbnctfbuj \nB decrypts to produce the following plaintext:  \nmareseatoatsanddoeseatoatsandlittlelambseativy  \nA simple frequency analysis confirms that this message has the profile of ordinary English. On the \nother hand, if an opponent generates the following random sequence of letters:  \nzuvrsoevgqxlzwigamdvnmhpmccxiuureosfbcebtqxsxq  \nthis decrypts to  \nytuqrndufpwkyvhfzlcumlgolbbwhttqdnreabdaspwrwp  \nwhich does not fit the profile of ordinary English. \nIt may be difficult to determine if incoming ciphertext decrypts to intelligible plaintext. If the \nplaintext is, say, a binary object file or digitized X -rays, determination of properly formed and \ntherefore authentic plaintext may be difficult. Thus, an op ponent could achieve a certain level of \n\ndisruption simply by issuing messages with random content purporting to come from a legitimate \nuser.  \nOne solution to this problem is to force the plaintext to have some structure that is easily recognized \nbut that c annot be replicated without recourse to the encryption function. We could, for example, \nappend an error-detecting code, also known as a frame check sequence (FCS) or checksum, to each \nmessage before encryption, as il lustrated in Figure 4.2, prepares a plain text message and then \nprovides this as input to a function F that produces an FCS. \n \n. The FCS is appended to and the entire block is then encrypted. At the destination, B M  decrypts \nthe incoming block and treats the results as a message with an appended FCS. B applies the same \nfunction F to attempt to reproduce the FCS.  If the calcu lated FCS is equal to the incoming FCS, \nthen the message is considered authentic. It is unlike ly that any random sequence of bits would \nexhibit the desired relationship. Note that the order in which the FCS and encryption functions are \nperformed is critical. The s equence illustrated in Figure4 .2a is referred to in [DIFF79] as internal \nerror control, which the authors contrast with external error control (Figure 4.2b). With internal \nerror control, authentication is provided because an opponent would have difficulty generating \nciphertext that, when decrypted, would have valid error control bits. If in stead the FCS is the outer \ncode, an opponent can construct messages with valid error -control codes. Although the opponent \ncannot know what the decrypted plaintext will be, he or she  can still hope to create confu sion and \ndisrupt operations \nPublic-Key Encryption The straightforward use of public-key encryption (Figure 4.1.b) provides \nconfidentiality but not authentication. The source (A) uses the public key  PUb ,of the destination \n(B) to encrypt. Because only B has the corresponding private key PR b, only B can decrypt the \nmessage. This scheme provides no authentication, because any opponent could also use B’s public \nkey to encrypt a message and claim to be A. \n\n \n   Figure 4.3: TCP segment \nTo provide authentication,  A uses its private key to encrypt the message, and B uses A’s \npublic key to decrypt (Figure 4.1c). This provides authentication using the same type of reasoning \nas in the symmetric encryption case: The message must have come from A because A is the only \nparty that possesses and therefore the only party with the information necessary to construct \nciphertext that can be decrypted with. Again, the same reasoning as before applies: There must be \nsome internal structure to the plaintext so that the receiver can distinguish between well -formed \nplaintext and random bits.  \nAssuming there is such structu re, then the scheme of Figure 4 .1c does provide \nauthentication. It also provides what is known as digital signature.1 Only A could have \nconstructed the ciph ertext bec ause only A possesses . Not even B, the recipient, could have \nconstructed the ciphertext. Therefore, if B is in possession of the ciphertext, B has the means to \nprove that the message must have come from A. In effect, A has “signed” the message by using its \nprivate key to encrypt. Note that this scheme does not provide confidentiality.  Anyone in \npossession of A’s public key can decrypt the ciphertext.  \nTo provide both confidentiality and authentication, A can encrypt first using its private \nkey, which provid es the digital signature, and then using B’s public key, which pro vides \nconfidentiality (Figure 4 .1d). The is  advantage of this approach is that the public -key algorithm, \nwhich is complex, must be exercised four times rather than two in each communication. \n \n \nMessage Authentication Code:  An alternative authentication technique involves the use of a \nsecret key to generate a small fixed -size block of data, known as a  cryptographic checksum or \nMAC, that is appended to the message. This technique assumes that two communicating parties, \nsay A a nd B, share a common secret key . When A has a message to send to B, it calculates the \nMAC as a function of the message and the key:  \nMAC = MAC(K, M) \nwhere  \nM= input message  \nC = MAC function  \nK= shared secret key  \nMAC = message authentication code  \n \n\n \n \nFigure 4.4: The basic use of Message Authentication Code \n \nThe message plus MAC are transmitted to the inten ded recipient. The recipient per forms the \nsame calculation on the received message, using the same secret key, to generate a new MAC. The \nreceived MAC is compared to the calculated MAC (Figure 4 .4a). If we assume that only the \nreceiver and the sender know the identity of the secret key, and if the received MAC matches the \ncalculated MAC, then \n1. The receiver is assured that the message has not been altered. If an attacker alters the \nmessage but does not alter the MAC, then the receiver’s calculation of the MAC will differ \nfrom the received MAC. Because  the attacker is assumed not to know the secret key, the \nattacker cannot alter the MAC to correspond to the alterations in the message. \n2. The receiver is assured that the message is from the alleged sender. Because no one else \nknows the secret key, no one else could prepare a message with a proper MAC. \n3. If the message includes a sequence number (such as is used with HDLC, X.25, and TCP), \nthen the receiver can be assured of the proper sequence because an attacker cannot \nsuccessfully alter the sequence number. \nA MAC function is similar to encryption. One difference is that the MAC algorithm need not be \nreversible, as it must be for decryption. In general, the MAC function is a many -to-one function. \nThe domain of the function consists of messages of some arbitrary  length, whereas the range \nconsists of all possible MACs and all possible keys. If an -bit MAC is used, then there are \npossible MACs, whereas there are possible messages with. Furthermore, with a -bit key, there are \npossible keys. \nBecause symmetric encryption will provide authentication and because it is  widely used with \nreadily available products, why not s imply use this instead of a sep arate message authentication \ncode? [DAVI89] suggests three situations in which a message authentication code is used. \n1. There are a number of applications in which the same message is broadcast to  a number of \ndestinations.  \nExamples are notification to users that the network  is now unavailable or an alarm signal \nin a military control center. It is cheaper  and more reliable to have only one destination \nresponsible for monitoring authenticity. Thus, the message must be broadc ast in plaintext \nwith an associated message authentication code. The responsible system has the secret key  \n\nand performs authentication. If a violation occurs, the other destination systems are alerted \nby a general alarm. \n2. Another possible scenario is an exchange in which one side has a heavy load  and can’ t \nafford the time to decrypt all incoming messages. Authentication  is carried out on a \nselective basis, messages being chosen at random for checking. \n3. Authentication of a computer program in plaintext is an attractive service. The  computer \nprogram can be executed without having to decrypt it every time, which would be wasteful \nof processor resources.  However, if a message authenti cation code were attached to the \nprogram, it could be checked whenever assur ance was required of the integrity of the \nprogram. \nThree other rationales may be added. \n4. For some applications, it may not be of concern to keep messag es secret, but it is  \nimportant to authenticate messages.  \nAn example is the Simple Network  Management Protocol Version 3 (SNMPv3), which \nseparates the functions of  confidentiality and authentication. For this application, it is \nusually important for a managed system to authenticate incoming SNMP messages, \nparticularly if the message contains a command to change parameters at the managed \nsystem. On the other hand, it may not be necessary to conceal the SNMP traffic.  \n5. Separation of authentication and confidentiality functions affords architectural flexibility. \nFor example, it may be desired to perform authentication at the application level but to \nprovide confidentiality at a lower level, such as the transport layer.  \n6. A user may wish to prolong the period of protection beyond the time of reception and yet \nallow processing of message contents. With message encryption, the protection is lost \nwhen the message is decrypted, so the message is protected against fraudulent \nmodifications only in transit but not within the target system.  \nFinally, note that the MAC does not provide a digital signature, because both sender and receiver \nshare the same key. \n4.3. REQUIREMENTS FOR MESSAGE AUTHENTICATION CODES \nA MAC, also known as a cryptographic checksum, is generated by a function C of the form  \nT = MAC(K, M) \nWhere \n M is a variable-length message \nK is a secret key shared only by sender and receiver \nMAC(K, M) is the fixed -length authenticator, sometimes called a tag. The tag is appended to \nthe message at the source at a time when the message is assumed or known to be correct. The receiver \nauthenticates that message by re-computing the tag.  \nWhen an entire mes sage is encrypted for co nfidentiality, using either sym metric or asymmetric \nencryption, the security of the scheme generally depends on the bit length of the key. Barring some \nweakness in the algorithm, the opponent must resort to a brute -force attack using all possible keys. On \naverage, such an attack will require 2(k-1)attempts for a k-bit key. In particular, for a ciphertext only \nattack, the opponent, given ciphertext C, Pi=D(Ki,C) performs for all possible key Ki values until a  Pi \nis produced that matches the form of acceptable plaintext. \nIn the case of a MAC, the considerations are entirely different. In general, the MAC function is a \nmany-to-one function, due to the many -to-one nature of the function. Using brute -force methods, how \nwould an opponent attempt to discover a key? If confidentiality is not employed, the opponent has \naccess to plaintext messages and their associated MACs. Suppose k>n; that is, suppose that the key \nsize is greater than the MAC size.  \nThen, given a known M1 and T1 , with T1 = MAC(K, M1) ,  \nThe cryptanalyst can perform Ti = MAC(Ki , M1) for all possible key values .  \nAt least one key is guaranteed to produce a match of  Ti = T1.  \nNote that a total of tags will be produced, but there are only 2n<2k different tag values. Thus, a number \nof keys will produce the correct tag and the opponent has no  way of knowing which is the correct key. \nOn average, a total of keys will produce a match. Thus, the o pponent must iterate the attack way of \nknowing which the correct key is. On average, a total of keys 2k /2n = 2(k-n) will produce a match. Thus, \nthe opponent must iterate the attack. \n \nAnd so on. On average, α rounds will be needed if . For example, if an  80-bit key is used and the tab \nis 32 bits, then the first round will produce about 248 possible keys. The second round will narrow the \npossible keys to about 216 possibilities. The third round should produce only a single key, which must \nbe the one used by the sender. \nIf the key length is less than or equal to the tag length, then it is likely that a first round will produce a \nsingle match. It is possible that more than one key will  produce such a match, in which case the \nopponent would need to perform the same test on a new (message, tag) pair. \nThus, a brute-force attempt to discover the authentication key is no less effort and may be more effort \nthan that required to discover a decryption key of the same  length. However, other attacks that do not \nrequire the discovery of the key are possible. \nA message authentication code (MAC) algorithm creates a message to be authenticated & a secret \nkey that is popular only to the sender of the message and the receiver of the message & creates a \nMAC as an output. By using MAC, a receiver can test the integrity of the message & authe nticity of \nthe message i.e., whether it is appearing from the proper sender or not. MAC does not supports Non -\nRepudiation. \nThree algorithms generally includes a MAC such as key generation algorithm, a signing algorithm \nand a verifying algorithm. The key generation algorithm selects a key at random. \nThe signing algorithm transmit a tag when likely the key and the message. The verifying algorithm \ncan be used to check the authenticity of the message when given the key and tag. It will restore a \nmessage of acce pted if the message and tag are authentic and same, but otherwise, it will restore a \nmessage of rejected. \n \nThere are some requirements for MACs are as follows − \n Message authentication codes (MACs) are generally used in digital funds transfers (EFTs) to \nsupport information integrity. They can validate that a message is authentic; that it actually \ndoes come, in other words, from the stated sender, and hasn’t sustained some changes en -\nroute. \n\n A verifier who also maintains  the key can use it to recognize chan ges to the element of the \nmessage in question. \n Message authentication codes are generally needed to access any type of financial account. \nBanks, brokerage firms, trust organization, and some other deposit, investment, or insurance \norganization that provide s online access can use these codes. They are an important \ncomponent of financial cryptography. \n1. If an opponent observes M and C (K, M) and it must be computationally impossible \nfor the opponent to make a message M' such that  \nC (K, M') = C (K, M). \n2. C (K, M)  should be consistently distributed in the sense that for randomly selected \nmessage, M and M', the probability that C (K, M) = C (K, M') is 2 -n, where n is the \nnumber of bits in the MAC. \n3. Let M' be same to some known transformation on M that is M'=f (M). Fo r instance, f \ncan include inverting one or more definite bits. In that case,  \nPr[C(K, M) = C(K, M')] = 2-n. \nSECURITY OF MACS \n Just as with encryption algorithms and hash functions, we can group attacks on MACs into two \ncategories: brute-force attacks and cryptanalysis. \nBrute-Force Attacks: \nA brute -force attack on a MAC is a more difficult undertaking than a brute -force attack on a hash \nfunction because it requires known message-tag pairs. Let us see why this is so. To attack a hash code, \nwe can proceed in the following way. Given a fixed message x with n -bit hash code h = H(x), a brute -\nforce method of finding a collision is to pick a random bit string and check if Hy) = H(x).The attacker \ncan do this repeatedly off line. Whether an off-line attack can be used on a MAC algorithm depends on \nthe relative size of the key and the tag. \nComputation resistance: Given one or more text -MAC pairs, [xi, MAC(K, xi)] it is  c omputationally \ninfeasible to compute any text-MAC pair [x, MAC(K, x)] for any new input  𝑥 ≠ xi. \nIn other words, the attacker would like to come up with the valid MAC code for a  given message. \nThere are two lines of attack possible: attack the key space and attack the MAC value.  We examine \neach of these in turn. \nCryptanalysis: \nAs with encryption algorithms and hash functions, cryptanalytic attacks on MAC algorithms seek to \nexploit some property of the algorithm to perform some attack other than an exhaustive search. The \nway to measure the resistance of a MAC algorithm to cryptanalysis is to compar e its strength to the \neffort required for a brute -force attack. That is, an ideal MAC algorithm will require a cryptanalytic \neffort greater than or equal to the brute-force effort. \nThere is much more variety in the structure of MACs than in hash functions,  so it is difficult to \ngeneralize about the cryptanalysis of MACs. \n \n4.4 HMAC \nHMAC (Hash-based Message Authentication Code ) is a type of message authentication code \n(MAC) that is acquired by executing a cryptographic hash function on the data that is to be \nauthenticated and a secret shared key. Like any of the MACs, it is used for both data integrity and \nauthentication. \n Unlike approaches based on signatures and asymmetric cryptography. Checking data integrity \nis necessary for the parties involved in communication. . The motivations for this interest are  \n1. Cryptographic hash functions such as MD5 and SHA generally execute faster in software \nthan symmetric block ciphers such as DES.  \n2. Library code for cryptographic hash functions is widely available.  ", "metadata": {"type": "text"}}
